package ua.hillel.a_sapon.Lesson_5;

import java.lang.Override;
import java.lang.String;
import java.util.concurrent.CompletionService;

/**
 * Class of complex numbers
 */
public class Complex {
    private double number;
    private double img;

    /**
    * Complex number zero constructor
    */
    Complex(){
        number=0;
        img=0;
    }

    /**
     * Complex number real numbers constructor
     */
    Complex (double number){

        this();
        this.number=number;
    }

    /**
     * Full scope constructor for number+i*img
     */
    Complex(double number, double img){

        this(number);
        this.img=img;
    }

    /**
     * Getters for each element separatly or for the Object itself
     */
    public double getNumber() {
        return number;
    }

    public double getImg() {
        return img;
    }

    public Complex getComplex(){
        return this;
    }

    /**
     * Setters for each element separatly or for the Object itself
     */
    public Complex setNumber(double number) {
        return new Complex(number,img);
    }

    public Complex setImg(double img) {
        return new Complex(this.number,img);
    }

    public Complex setComplex(double number, double img)
    {
        return new Complex(number,img);
    }

    /**
     * Lets realize equals
     */
    public boolean equals(Object object) {

        if (this == object) return true;

        //we are not going to use autogenerated code in whole scope and will define our part of comperison algorithm as well
        if ( object != null && getClass() == object.getClass() ){

            Complex complex = (Complex) object;
            return (( complex.getImg() == this.img ) &&
                    ( complex.getNumber() == this.number));
        }
        else return false;

        /*
        if (object == null || getClass() != object.getClass()) return false;
        if (!super.equals(object)) return false;
        Complex complex = (Complex) object;
        return Double.compare(complex.number, number) == 0 &&
                Double.compare(complex.img, img) == 0;*/


    }

    /**
     * AutoGenerated hashCode
     * @return int
     */
    public int hashCode() {
        //also not going to use autogenerated algorithm and will use our approach for calculation of such
        //just for fun
        return (int)( 31*this.number + (int)( this.number % (int) this.img ) );

        //return java.util.Objects.hash(super.hashCode(), number, img);
    }

    /**
     * toString
     * @return string in a format "Complex number = %d . img= %d"
     */
    @Override
    public String toString() {
        return "Complex{" +
                "number=" + this.number +
                ", img=" + this.img +
                '}';
    }

    /*
      Lets define some operations
    */

    /**
     * Sum
     * (a1+b1i)+(a2+b2i) = (a1+a2) + (b1+b2)i
     */
    public Complex sum(Complex complex) {

        return new Complex(complex.getNumber() + this.number, complex.getImg() + this.img);
    }

    /**
     * Substract
     * (a1+b1i)-(a2+b2i) = (a1-a2) + (b1-b2)i
     */
    public Complex substract(Complex complex) {

        return new Complex(complex.getNumber() - this.number, complex.getImg() - this.img);
    }

    /**
     * Multiplication
     * (a1+b1i)*(a2+b2i) = (a1a2-b1b2) + (a1b2+b1a2)i
     */
    public Complex multiply(Complex complex){

        return new Complex( (complex.getNumber() * this.number) - (complex.getImg() * this.img),
                (complex.getNumber() * this.img) + (complex.getImg() * this.number));
    }


    /**
     * Division
     * (a1+b1i)/(a2+b2i) = (a1a2+b1b2)/(a2a2+b2b2) + (a2b1-a1b2)/(a2a2+b2b2)
     */
    public Complex divideOn(Complex cmplx){

        return new Complex(
                ( cmplx.getNumber()*this.number + cmplx.getImg()*this.img ) / ( cmplx.getNumber()*cmplx.getNumber() + cmplx.getImg()*cmplx.getImg() )
                ,
                ( cmplx.getNumber()*this.img - cmplx.getImg()*this.number ) / ( cmplx.getNumber()*cmplx.getNumber() + cmplx.getImg()*cmplx.getImg() )
        );
    }

    /**
     * Module
     * |a1+b1i| = sqrt ( a1*a1 + b1*b1 )
     */
    public double abs(){
        return (Math.sqrt(this.number*this.number + this.img*this.img));
    }

    /**
     * Exponentiation of the complex number in defined int power
     * (a1+b1i) to N power = ( abs|a1+b1i| power N )*( cos( N*f ) + i sin ( N*f ) )
     * I'm to lasy so wont be using a special formula here
     */
    public Complex power(int power){

        Complex cmplx = new Complex(0,0);

            if (power < 0){
                throw new RuntimeException("method doesnt allow negative power");
                //return new Complex(0,0);
            }

            if (power == 0) {
                return new Complex(1, 0);
            }

            if (power > 0) {

                for (int i = 1; i < power; i++) {
                    cmplx = multiply(this);
                }
            }

        return cmplx;
    }

    /**
     * As an addition to all those methods next one can be determined as well
     * Root Number
     * cos
     * sin
     * tg
     * ln
     * log
     * atc...
     * ... but Im to lasy for that
     */

    /**
     * As for the logical operations ...
     */

    /**
     * Equals is already defined
     */

    /**
     * NotEqual
     */
    public boolean notEquals(Object object){
        return !equals(object);
    }

    /**
     * Greater or Equal
     * frankly speaking Complex numbers are those which cannot be compared
     * there is no simple algorithm how to do it whcih can be applied for any condition
     * we can compare either by abs or also add into the formula of comparison an angle itself, between complex vector and   x axis (real part)
     * or we can define it something like:
     * a1+b1i>a2+b2i if {(a1>a2) || ( (a1==a2) && (b1>b2) )}
     *
     * in our case, to keep it simple, lets compare it by abs
     */
    public boolean greaterOrEqual(Complex cmplx){

        /*
        //this part of the code is also questionable
        // should we additionally compare to complex numbers if their abs are equal
        // or do we accpet that our algorithm can grant positive results even if  equals() return false
        //depending on that next part of the code can be included
        //but we ommit it

        if (this.abs() == cmplx.abs()){
            return this.equals(cmplx);
        }
        */

        return this.abs() >= cmplx.abs();
    }

    /**
     * Less or Eqal
     */
    public boolean lessOrEqual(Complex cmplx){

        return this.abs() <= cmplx.abs();
    }

    /**
     * Strictly Greater
     */
    public boolean greater(Complex cmplx){

        return this.abs() > cmplx.abs();
    }

    /**
     * Strictly Less
     */
    public boolean less(Complex cmplx){

        return this.abs() < cmplx.abs();
    }

    /**
     * Also can be realized High Level Mathematics such as Limits, Integrals etc ...
     * but I dont think that it's required in the scope of the task
     */
}
